/**
 * 
 * Common.js不适应与客户端，原因在知识点2
 * 
 * 出现了Amd是指Asynchronous Module Definition，异步的模块加载机制，CMD是Common Module Definition，
 * 知识点1：AMD/CMD/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs.
 * 知识点2：CommonJs主要针对服务端，AMD/CMD主要针对浏览器端，所以最容易混淆的是AMD/CMD。
 *      （顺便提一下，针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，
 *      服务器端便停下来，等待它加载再执行。这里如果有其他后端语言，如java经验的‘玩家’应该更容易理解。而浏览器端要保证效率，
 *      需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好。）
 * 知识点3 : AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块
 *      （因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，
 *      但是不会执行，而是在需要的时候才执行。
 * 知识点4：AMD/CMD的优缺点.一个的优点就是另一个的缺点， 可以对照浏览。
        AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。
        AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。
        CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。
        CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，
        尤其在文件较多较大时，这种缺点尤为明显。

   知识点5：如何使用？
        CommonJs的话，因为nodeJs就是它的实现，所以使用node就行，也不用引入其他包。
        AMD则是通过<script>标签引入RequireJs，具体语法还是去看官方文档或者百度一下吧。CMD则是引入SeaJs。

    区别：
    1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。
        CMD 推崇 as lazy as possible，懒加载,提前读取文件，但在需要再加载
    2. CMD 推崇依赖就近，AMD 推崇依赖前置。
    3.


ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。
    CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，
    比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。


 * 
 */